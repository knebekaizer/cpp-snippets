







<!-- check referer -->


 





		 

		


 

		<html>
		<head>
<!--SiteCatalyst code version: G.7. Copyright 1997-2004 Omniture, Inc.
More info available at http://www.omniture.com
-->
<script language="JavaScript">
<!--
var s_pageName="";
var s_server="";
var s_channel="";
var s_pageType="";
var s_prop1="";
var s_prop2="";
var s_prop3="Dr. Dobb's Journal | 220300654 | Algorithm Improvement through Performance Measurement: Part 2";
var s_prop4="Algorithm Improvement through Performance Measurement: Part 2";
var s_prop5="C++ | Development Tools | High Performance Computing | Architecture & Design";
var s_prop6="";
var s_prop7="Victor J. Duvanenko";
var s_prop8="77.88.4.133 | Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.9.1.3) Gecko/20090824 Firefox/3.5.3 (.NET CLR 3.5.30729)";
var s_prop9="";
var s_prop10="";
var s_prop11="";
var s_prop12="";
var s_prop13="http://www.ddj.com/article/printableArticle.jhtml?articleID=220300654&dept_url=/cpp/";
var s_prop14="";
var s_prop15="";
var s_prop16="";
var s_prop19="False";

/* E-commerce Variables */
var s_campaign="";
var s_state="";
var s_zip="";
var s_events="event5";
var s_products="";
var s_purchaseID="";
var s_eVar1="";
var s_eVar2="";
var s_eVar3="";
var s_eVar4="";
var s_eVar5="";
var s_eVar22="";
var s_eVar23="False";
//-->
</script>

			
			<title>Dr. Dobb's | Algorithm Improvement through Performance Measurement: Part 2 | October 1, 2009</title>
		</head>

		<body bgcolor="#ffffff">
<table cellpadding=0 cellspacing=0>
<tr>
<td><script> var ckRef=document.referrer; if(ckRef && ckRef.indexOf('/as5/redirect/')==-1 || !ckRef) { document.write('<script language="JavaScript" src="http://i.cmpnet.com/shared/omniture/s_code_remote.js"><\/script>'); document.close(); }</script></td>
</tr>
</table>
<!-- End SiteCatalyst code version: G.7. -->

		



		<!-- http://as.cmpnet.com/html.ng/pagepos=top&affiliate=ddj&site=sdmg&country=russian_federation&server=atg&target=/article/printableArticle.jhtml -->
<a target="_parent" href="http://as.cmpnet.com/event.ng/Type=click&FlightID=152671&AdID=240334&TargetID=1251&Segments=1551,3108,3299,3448,4875,5470,10552,14765&Targets=1251,2625,2878,4879&Values=34,46,51,63,77,87,90,102,140,203,442,774,944,945,975,1766,1785,1925,1970,2151,2299,2329,2352,2678,3351,3363,4079,6293,6393,6489,6541,6567,6967,7062&RawValues=IP,66.77.24.210,&Redirect=http://www.microsoftpdc.com"><img src="http://i.cmpnet.com/ads/graphics/as5/kh/house/728x90_PDC09e_20k_091409.gif" border=0 height=90 width=728 alt=""></a><img src="http://as.cmpnet.com/event.ng/Type=count&ClientType=2&AdID=240334&FlightID=152671&TargetID=1251&SiteID=944&AffiliateID=975&EntityDefResetFlag=0&Segments=1551,3108,3299,3448,4875,5470,10552,14765&Targets=1251,2625,2878,4879&Values=34,46,51,63,77,87,90,102,140,203,442,774,944,945,975,1766,1785,1925,1970,2151,2299,2329,2352,2678,3351,3363,4079,6293,6393,6489,6541,6567,6967,7062&RawValues=&random=bdkobln,bfmRcrxfcghI" width=1 height=1 border=0>

	<br>
		<TABLE border="0" width="900" cellpadding="0" cellspacing="0" class="elfixo">
			<TR>
				<TD width="1" bgcolor="#000000" rowspan=2><img src="http://i.cmpnet.com/ddj/blank.gif" border="0" width="1" height="1" alt=""></td>
				<TD width="362" bgcolor="#000000"><img src="http://i.cmpnet.com/ddj/blank.gif" border="0" width="362" height="1" alt=""></td>
				<TD width="536" bgcolor="#000000"><img src="http://i.cmpnet.com/ddj/blank.gif" border="0" width="536" height="1" alt=""></td>
				<TD width="1" bgcolor="#000000" rowspan=2><img src="http://i.cmpnet.com/ddj/blank.gif" border="0" width="1" height="1" alt=""></td>
			</TR>
			<TR>
				<TD align=left valign=middle bgcolor="#349F2C"><a href="/;jsessionid=I1EPXX1MIXKS5QE1GHRSKH4ATMY32JVN"><img src="http://i.cmpnet.com/ddj/logo_ddj.gif" width="356" height="45" hspace="3" vspace="5" border="0" alt=""></a></TD>
				<TD valign=top align=right bgcolor="#349F2C"></td>
			</TR>
			<TR>
				<TD colspan=4 bgcolor="#000000"><img src="http://i.cmpnet.com/ddj/blank.gif" border="0" width="250" height="1" alt=""></TD>
			</TR>
		</TABLE>
		<br>
		<font size="5">Algorithm Improvement through Performance Measurement: Part 2</font>
		<p>
		<font size="4">In-place Hybrid Binary-Radix Sort</font><br>
		<p>
		<font size="2" face="geneva,arial,helvetica">By 
			

					
								Victor J. Duvanenko,&nbsp;
						

					 
				

			 

					










    

        

        

            

                
      
                <!-- remove http:// substring (if present) from the url -->
                

                
                    
                  

                

                <a href="http://www.ddj.com/;jsessionid=I1EPXX1MIXKS5QE1GHRSKH4ATMY32JVN" target="_blank">
                Dr. Dobb's Journal
                </a>

              

          

      

  


				
			<br>
			Oct 01, 2009
			<br>
			URL:<a href="/cpp/220300654;jsessionid=I1EPXX1MIXKS5QE1GHRSKH4ATMY32JVN"/>http://www.ddj.com/cpp/220300654
			</a><br><br>
		</font>
		<P>
		<!-- ARTICLE BODY -->
		
				<hr>
<a href="http://www.ddj.com/architect/220000504">Algorithm Improvement through Performance Measurement: Part 1</a>
<hr>
<P>

Radix sorting algorithms do not compare elements of the array to each other and thus are not bound by <b><i>O</i>(nlogn)</b> performance limit of comparison-based sorting algorithms. In fact, they have <b><i>O</i>(kn)</b> linear performance.  Radix Sort processes array elements one digit at a time, starting ether from the most significant digit (MSD) or the least significant digit (LSD).  For example, to sort the following array of 2-digit numbers:
<P>
<div>
<img src="http://i.cmpnet.com/ddj/images/article/2009/0910/091001victor2_e5.gif"> 
</div>
<P>

<P>
One way to implement Radix Sort is to take the input array and look at the highest digit of each element.  Create a bin (a separate array) for 0's, a bin for 1's, a bin for 2's,, a bin for 9's.  Put all array elements into the bin where the most-significant-digit matches the bin number.  Then continue doing this recursively for each bin, based on the next digit.  Once all numbers are split into separate bins based on all of their digits, collect them starting with the smallest most significant digit and smallest next digit and so on; for example, collect all digits in the 00 bin, then 01 bin, then 02 bin, , 09 bin, 10 bin, 11 bin and so on until 99 bin. The result is a sorted array.
<P>

<P>
One weakness of Radix sort algorithms is the requirement of extra storage (for bins) besides the input array; that is, not being in-place.  For instance, Intel's <a href="http://software.intel.com/en-us/intel-ipp/">Integrated Performance Primitives (IPP) library</a> implements a Radix-sort algorithm with the function call prototype of:
<P>
<pre  class="code">
<P>
IppStatus ippsSortRadixAscend_32u_I(Ipp32u* pSrcDst, Ipp32u* pTmp, Ipp32s len);
<P>


</pre>
<P>

<P>
The temporary vector <b>pTmp</b> is required by the algorithm, with size equal to that of the source vector &#91;1&#93;.  Note, that the array is labeled pSrcDst, indicating that the array serves as both the source and the destination for the sorting operation.  Intel's IPP library also implements a non-Radix sort with the function call prototype of: 
<P>
<pre  class="code">
<P>
IppStatus ippsSortAscend_32s_I(Ipp32s* pSrcDst, int len);

</pre>
<P>

<P>
which requires no additional storage -- that is, it is in-place.
<P>

<P>
The radix does not have to be decimal, but can be any integer.  For example, decimal-Radix is base-10 (with values 0 through 9), hex-radix is base-16 (values 0 through 15), octal-radix is base-8 (values 0 through 7), and binary-radix is base-2 (values 0 and 1).
<P>
<h3>Binary-Radix</h3>
<P>

<P>
Decimal-Radix is familiar for humans, but binary-radix (base-2) is the smallest useful radix.  With binary-radix there are only two possible bins: 0's bin and 1's bin.  For example, the array is scanned from the beginning to the end while looking at the most-significant-digit, which is the most-significant-bit (MSB) for a binary-radix.  If the MSB is a zero, then the array element goes into 0's bin, or if the MSB is a 1, then the array element goes into 1's bin.
<P>

<P>
After splitting the original array into these two bins, the number of elements in 0's bin plus the number of elements in 1's bin add up to the number of elements in the original array.  The 0's bin can now be split into 0's bin and 1's bin, using the next bit as the sorting decision.  The same is done with the 1's bin.  This process continues recursively until all bits have been exhausted.  Figure 1 illustrates this procedure.
<P>
<div>
<img src="http://i.cmpnet.com/ddj/images/article/2009/0910/091001victor2_f1.gif"> 
<div class="caption">
<b>Figure 1</b>
</div>
</div>
<P>

<P>
For instance, if the array elements are 32-bit, then 32 passes over each array element will be performed, sorting it into 0's and 1's bin for each of the 32-bits.  Thus, Binary-Radix Sort is <b><i>O</i>(kn)</b>, where <b>k</b> is the number of bits in each array element and <b>n</b> is the number of array elements.  In other words, each array element will be processed 32 times, once for each of its bits.
<P>
<h3>In-place</h3>
<P>

<P>
In-place is a useful property for a sorting algorithm, where the input array is processed without requiring additional memory, and serves as the output array.  If an algorithm is in-place, then it can process larger arrays than an algorithm that is not in-place.  This difference was illustrated above with Intel's IPP functions for Radix Sort, which requires additional memory of equal size to the original array and is not in-place.  However, the IPP non-Radix Sort requires no additional memory and is in-place.
<P>

<P>
Binary Radix-Sort can be made in-place by the following method.  Instead of allocating additional memory for 0's bin and 1's bin, the original array can be used to store elements of both bins.  The 0's bin is grown from the beginning of the array, and the 1's bin is grown from the end of the array.  When the binning process is done, these two bins will meet somewhere within the array, and will not overlap.
<P>

<P>
In the next iteration of the algorithm, the bins are created based on the next most-significant-bit, where the 0's bin from the first iteration is split into two bins: 0's bin and 1's bin.  The same is done for the 1's bin from the first iteration.  This process continues recursively until all bits of the elements have been processed.
<P>

<P>
The first iteration of this algorithm, which sorts based on the most-significant-bit (MSB), is demonstrated below.  The pointer on the left keeps track of 0's bin current location.  The pointer on the right keeps track of 1's bin current location.
<P>
<div>
<img src="http://i.cmpnet.com/ddj/images/article/2009/0910/091001victor2_e1.gif"> 
</div>
<P>

<P>
Note that all array elements with MSB of zero are moved to the left side of the array, and the elements with MSB of one are moved to the right side of the array.  The array is not completely sorted yet.  The algorithm calls itself recursively with the 0's bin (the left side of the array), and the 1's bin (the right side of the array), and sort both based on the next bit.  Then the algorithm calls itself recursively one more time to sort based on the last bit.
<P>

<P>
Listing 1 shows an implementation for in-place Binary-Radix Sort algorithm. 
<P>
<pre  class="code">
<P>
// Copyright(c), Victor J. Duvanenko, 2009
// In-place Binary Radix Sort implementations.
<P>
#ifndef _InPlaceBinaryRadixSort1_h
#define _InPlaceBinaryRadixSort1_h
<P>
// Swap that does not check for self-assignment.
template&lt; class _Type &gt;
inline void _swap( _Type& a, _Type& b )
{
	_Type tmp = a;
	a         = b;
	b         = tmp;
}
<P>
template&lt; class _Type &gt;
inline void _binaryRadixSort_initialUnsigned( _Type* a, long first, long last, _Type bitMask )
{
	// Split the provided array range into 0's and 1's bins
	long _zerosEndPlusOne = first;						// index is one beyond the last  0's bin
	long _onesEndMinusOne = last;						// index is one before the first 1's bin
	for ( ; _zerosEndPlusOne &lt;= _onesEndMinusOne; )
	{
		if ( 0 == ( bitMask & a&#91; _zerosEndPlusOne &#93; ))				// 0's bin
		{
			// this element belongs in the 0's bin
			// it stays at its current location and the 0's bin size is increased
			_zerosEndPlusOne++;
		}
		else {														// 1's bin
			_swap( a&#91; _zerosEndPlusOne &#93;, a&#91; _onesEndMinusOne &#93; );	// move this element to 1's bin
			_onesEndMinusOne--;										// increase the 1's bin size
		}
	}
	// At this point the provided array portion has been split into 0's bin and 1's bin
	// Recursively call to sort this 0's bin and this 1's bin using the next bit lower
	bitMask &gt;&gt;= 1;
	if ( bitMask != 0 )						// end recursion when all the bits have been processes
	{
		if ( first &lt; ( _zerosEndPlusOne - 1 ))
			_binaryRadixSort_initialUnsigned( a, first, _zerosEndPlusOne - 1, bitMask );
		if (( _onesEndMinusOne + 1 ) &lt; last )
			_binaryRadixSort_initialUnsigned( a, _onesEndMinusOne + 1,  last, bitMask );
	}
}
inline void binaryRadixSortInPlace_initialUnsigned( unsigned long* a, unsigned long a_size )
{
	if ( a_size &lt; 2 )	return;
<P>
	unsigned long bitMask = 0x80000000;
<P>
	_binaryRadixSort_initialUnsigned( a, 0, a_size - 1, bitMask );
}
endif	// _InPlaceBinaryRadixSort_h

</pre>
<div>
<div class="caption">
<b>Listing 1</b>
</div>
</div>
<P>

<P>
The outermost routine <b>binaryRadixSortInPlace_initialUnsigned()</b> sets the initial bit-mask to select the most significant bit and calls a template function <b>_binaryRadixSort_initialUnsigned()</b>.  This core function splits the provided array range, between first and last elements, into 0's bin and 1's bin, in-place.  Then it shifts the bit-mask to the right to select the next bit down, and calls itself recursively twice: once for the 0's bin, and the second time for the 1's bin.  During the splitting process the algorithm uses the <b>_swap()</b> generic function template to move the element to 1's bin.
<P>

<P>
Table 1 shows performance benchmarks of in-place Binary-Radix Sort, STL sort, and Intel's IPP Radix-sort functions for an array of random unsigned 32-bit elements.  Intel IPP library also has a non-Radix sort function, which handles a variety of input data types, but not 32-bit unsigned integers &#91;1&#93;.
<P>
<div>
<img src="http://i.cmpnet.com/ddj/images/article/2009/0910/091001victor2_t1.gif"> 
<div class="caption"> 
<b>Table 1</b>: Random 32-bit Unsigned Elements 
</div>
</div>
<P>

<P>
These measurements and the ratios computed from them show that Binary-Radix Sort approaches STL sort in performance for random input data sets.  Intel's IPP Radix Sort outperformed Binary-Radix Sort by about 4-6X, for 32-bit unsigned numbers.

			
				<h3>Test Setup</h3>
<P>

<P>
One method for verification of correctness is to compare algorithm implementations to STL sort for assurance of equivalent results, but that assumes STL sort is correct.  To not rely on correctness of STL sort requires implementing a correctness test for sorting algorithms.  Correctness requires that <b>array&#91;i&#93; &#8804; array&#91;i+1&#93;</b> for all elements of the array, which is simple to check.  Of course, comparison to results from STL sort would be a useful redundant verification.  These two tests were used for all implemented routines, including Intel's IPP library routines.  Boundary cases of the input arrays of size 0 and 1 were also tested.
<P>

<P>
The performance comparison setup was as follows:
<P>
<ul>
<li>Visual Studio 2008, optimization project setting is set to optimize neither speed or size, and inline any suitable function.
<li>Intel Core 2 Duo CPU E8400 at 3 GHz (64 Kbytes L1 and 6 Mbytes L2 cache). 
<li>14-stage pipeline with 1,333 MHz front-side bus.
<li>2 GB of system memory (dual-channel 64-bits per channel, 800 MHz DDR2).
<li>motherboard is DQ35JOE.
</ul>
<P>

<P>
Random numbers were generated by using the following method for each element in the array:
<P>
<pre  class="code">

// each call to rand() produces 15-bit random number.
unsigned long tmp = ((unsigned long)rand()) &lt;&lt; 30 |
                    ((unsigned long)rand())&lt;&lt;  15 |
                    ((unsigned long)rand());
</pre>
<P>

<P>
The arrays were all checked for percentage of unique values, which were all above 95% for arrays filled with 32-bit unsigned values.  The range of min and max were also checked for each array, which were between 0 and near the max value for 32-bit unsigned numbers.
<P>

<P>
Performance was measured by always processing 100 million elements.  When 10 element arrays were being measured, then 10 million of them were allocated.  When 100 element arrays were being measured, then 1 million of them were allocated, and so on.  A different random-number generator seed was used for each array, but the same seeds were used across all algorithms.  Time-stamp was taken before sorting the 10 million arrays and also after.  The average value across all arrays is the value reported.

			
				<h3>Hybrid</h3>
<P>

<P>
The STL <b>sort</b> implementation combines three different sorting algorithms to extract the best attributes of each, resulting in superior overall performance.  STL sort combines the best of QuickSort, Heap Sort, and Insertion Sort algorithms, enabling each under different conditions, where each excels over others.  It starts out using QuickSort for <b>1.5*log2(n)</b> divisions of recursion depth, followed by Heap Sort if the resulting divisions still hold more than 32 elements, and Insertion Sort if they hold between 32 and 2 elements.  Insertion Sort provides good cache locality at the leaf nodes of the binary recursion tree, and it is adaptive to input data &#91;4&#93;.  Ending recursion at about 32 elements avoids the function call and return overhead when the number of elements is small.
<P>

<P>
The same good ideas can be applied to Radix Sort (Binary or higher radix).  Listing 2 shows such an implementation, which uses a version of Insertion Sort from &#91;4&#93;, also included in Listing 2.  
<P>
<pre  class="code">
<P>
// Copyright(c), Victor J. Duvanenko, 2009
// In-place Binary Radix Sort implementations.
<P>
#ifndef _InPlaceBinaryRadixSort2_h
#define _InPlaceBinaryRadixSort2_h
<P>
// Swap that does not check for self-assignment.
template&lt; class _Type &gt;
inline void _swap( _Type& a, _Type& b )
{
	_Type tmp = a;
	a         = b;
	b         = tmp;
}
<P>
template&lt; class _Type &gt;
inline void insertionSortSimilarToSTLnoSelfAssignment( _Type* a, unsigned long a_size )
{
	for ( unsigned long i = 1; i &lt; a_size; i++ )
	{
		if ( a&#91; i &#93; &lt; a&#91; i - 1 &#93; )		// no need to do (j &gt; 0) compare for the first iteration
		{
			_Type currentElement = a&#91; i &#93;;
			a&#91; i &#93; = a&#91; i - 1 &#93;;
			unsigned long j;
			for ( j = i - 1; j &gt; 0 && currentElement &lt; a&#91; j - 1 &#93;; j-- )
			{
				a&#91; j &#93; = a&#91; j - 1 &#93;;
			}
			a&#91; j &#93; = currentElement;	// always necessary work/write
		}
		// Perform no work at all if the first comparison fails - i.e. never assign an element to itself!
	}
}
<P>
inline void _binaryRadixSort_wInsertion( unsigned long* a, long first, long last, unsigned long bitMask )
{
	if (( last - first ) &gt; 32 )
	{
		// Split the provided array range into 0's and 1's sub-ranges
		long _zerosEndPlusOne = first;						// index is one beyond the last  0's portion
		long _onesEndMinusOne = last;						// index is one before the first 1's portion
		for ( ; _zerosEndPlusOne &lt;= _onesEndMinusOne; )
		{
			if ( 0 == ( bitMask & a&#91; _zerosEndPlusOne &#93; ))			// 0's portion
			{
				// nothing to do, as this is our 0's portion of the array
				_zerosEndPlusOne++;
			}
			else {											// 1's portion
				_swap( a&#91; _zerosEndPlusOne &#93;, a&#91; _onesEndMinusOne &#93; );
				_onesEndMinusOne--;
			}
		}
		// Recursively call to sort 0's portion and 1's portion using the next bit lower
		bitMask &gt;&gt;= 1;
		if ( bitMask != 0 )
		{
			if ( first &lt; ( _zerosEndPlusOne - 1 ))
				_binaryRadixSort_wInsertion( a, first, _zerosEndPlusOne - 1, bitMask );
			if (( _onesEndMinusOne + 1 ) &lt; last )
				_binaryRadixSort_wInsertion( a, _onesEndMinusOne + 1,  last, bitMask );
		}
	}
	else {
		insertionSortSimilarToSTLnoSelfAssignment( &a&#91; first &#93;, last - first + 1 );
	}
}
inline void binaryRadixSortInPlace_wInsertion( unsigned long* a, unsigned long a_size )
{
	if ( a_size &lt;  2 )	return;
	unsigned long bitMask = 0x80000000;
<P>
	_binaryRadixSort_wInsertion( a, 0, a_size - 1, bitMask );
}
<P>
endif	// _InPlaceBinaryRadixSort_h

</pre>
<div>
<div class="caption">
<b>Listing 2</b>
</div>
</div>
<P>

<P>
Tables 2 through 5 and Graph 1 compare performance of Hybrid Binary-Radix Sort with STL sort and IPP Radix Sort.
<P>
<div>
<img src="http://i.cmpnet.com/ddj/images/article/2009/0910/091001victor2_t2.gif"> 
<div class="caption"> 
<b>Table 2</b>: Random 32-bit Unsigned Elements 
</div>
</div>
<P>

<P>

<P>
<div>
<img src="http://i.cmpnet.com/ddj/images/article/2009/0910/091001victor2_e2.gif"> 
<div class="caption"> 
<b>Graph 1</b>
</div>
</div>
<P>

<P>

<P>
<div>
<img src="http://i.cmpnet.com/ddj/images/article/2009/0910/091001victor2_t3.gif"> 
<div class="caption"> 
<b>Table 3</b>: Increasing 32-bit Unsigned Elements 
</div>
</div>
<P>

<P>

<P>
<div>
<img src="http://i.cmpnet.com/ddj/images/article/2009/0910/091001victor2_t4.gif"> 
<div class="caption"> 
<b>Table 4</b>: Decreasing 32-bit Unsigned Elements 
</div>
</div>
<P>

<P>
These measurements and the ratios computed from them, show that the Hybrid Binary-Radix Sort consistently outperforms STL sort for random input data set, by 20%, but not for increasing and decreasing input data sets, where it lags by up to 40%.  Intel's IPP Radix Sort outperformed all others by at least 3X for random input data, but lagged STL sort for other data input statistics.
<P>
<h3>Improvements</h3>
<P>

<P>
Several inefficiencies are noticeable in the sorting example of six 3-bit numbers above:
<P>
<ul>
<li>In the next-to-last step of the algorithm, the element <b>a<sub>2</sub></b> is swapped with itself.
<li>In lines 3 and 4, the swaps are performed between elements which both belong to the 1's bin.
</ul>
<P>

<P>
The first improvement can be implemented using a method similar to that used in &#91;4&#93;, where self-assignment was eliminated without performing additional work.  In this case, the last loop can be extracted from the for loop by changing the comparison from &b>&lt;=</b> to <b>&lt;</b>.  The tricky detail here is that:
<P>
<pre  class="code">
<P>
if (_zerosEndPlusOne == _onesEndMinusOne )

</pre>
<P>

<P>
is not necessary and can be removed, because all recursion calls check to make sure that each bin holds at least two elements.  Thus, the <b>for</b> loop is guaranteed to run for at least one iteration, leaving the "==" condition as the only work left after the for loop; for example, the only work left is when a single element is left (and a swap is not necessary).  Note that in this case, the amount of work was actually reduced to handle this condition, since the "==" comparison was removed.  This optimization resulted in 4-5% performance improvement for random input data set of 32-bit unsigned integers.  The implementation is in Listing 3.
<P>
<pre  class="code">
<P>
// Copyright(c), Victor J. Duvanenko, 2009
// In-place Binary Radix Sort implementations.
<P>
#ifndef _InPlaceBinaryRadixSort3_h
#define _InPlaceBinaryRadixSort3_h
<P>
// Swap that does not check for self-assignment.
template&lt; class _Type &gt;
inline void _swap( _Type& a, _Type& b )
{
	_Type tmp = a;
	a         = b;
	b         = tmp;
}
<P>
template&lt; class _Type &gt;
inline void insertionSortSimilarToSTLnoSelfAssignment( _Type* a, unsigned long a_size )
{
	for ( unsigned long i = 1; i &lt; a_size; i++ )
	{
		if ( a&#91; i &#93; &lt; a&#91; i - 1 &#93; )		// no need to do (j &gt; 0) compare for the first iteration
		{
			_Type currentElement = a&#91; i &#93;;
			a&#91; i &#93; = a&#91; i - 1 &#93;;
			unsigned long j;
			for ( j = i - 1; j &gt; 0 && currentElement &lt; a&#91; j - 1 &#93;; j-- )
			{
				a&#91; j &#93; = a&#91; j - 1 &#93;;
			}
			a&#91; j &#93; = currentElement;	// always necessary work/write
		}
		// Perform no work at all if the first comparison fails - i.e. never assign an element to itself!
	}
}
<P>
template&lt; class _Type &gt;
inline void _binaryRadixSortNoSelfAssignment_unsigned( _Type* a, long first, long last, _Type bitMask )
{
	// Split the provided array range into 0's and 1's portions
	long _zerosEndPlusOne = first;						// index is one beyond the last  0's portion
	long _onesEndMinusOne = last;						// index is one before the first 1's portion
	for ( ; _zerosEndPlusOne &lt; _onesEndMinusOne; )
	{
		if ( 0 == ( bitMask & a&#91; _zerosEndPlusOne &#93; ))				// 0's portion
		{
			// this element belongs in the 0's portion
			// so just keep it in its place and grow the 0's portion size
			_zerosEndPlusOne++;
		}
		else {														// 1's portion
			_swap( a&#91; _zerosEndPlusOne &#93;, a&#91; _onesEndMinusOne &#93; );	// move this element to 1's portion
			_onesEndMinusOne--;
		}
	}
	if ( 0 == ( bitMask & a&#91; _zerosEndPlusOne &#93; ))				// 0's portion
	{
		_zerosEndPlusOne++;
	}
	else {														// 1's portion
		_onesEndMinusOne--;										// No swap is needed, since it's self-assignment
	}
	// Recursively call to sort 0's portion and 1's portion using the next bit lower
	bitMask &gt;&gt;= 1;
	if ( bitMask != 0 )						// end recursion when all the bits have been processes
	{
		if ( first &lt; ( _zerosEndPlusOne - 1 ))		// call only if number of elements &gt;= 2
			_binaryRadixSortNoSelfAssignment_unsigned( a, first, _zerosEndPlusOne - 1, bitMask );
		if (( _onesEndMinusOne + 1 ) &lt; last )		// call only if number of elements &gt;= 2
			_binaryRadixSortNoSelfAssignment_unsigned( a, _onesEndMinusOne + 1,  last, bitMask );
	}
}
<P>
inline void binaryRadixSortInPlaceNoSelfAssignment_unsigned( unsigned long* a, unsigned long a_size )
{
	if ( a_size &lt; 2 )	return;
<P>
	unsigned long bitMask = 0x80000000;
<P>
	_binaryRadixSortNoSelfAssignment_unsigned( a, 0, a_size - 1, bitMask );
}
<P>
endif	// _InPlaceBinaryRadixSort_h

</pre>
<div>
<div class="caption">
<b>Listing 3</b>
</div>
</div>
<P>

<P>
The second improvement was prompted by &#91;5&#93; and shows up clearly in the sorting example above.  Listing 4 shows an implementation which removes redundant swaps of elements that both belong to the 1's bin.  Instead, the algorithm switches to growing the 1's bin while looking for a 0's bin element to swap with.  
<P>
<pre  class="code">
<P>
// Copyright(c), Victor J. Duvanenko, 2009
// In-place Binary Radix Sort implementations.
<P>
#ifndef _InPlaceBinaryRadixSort4_h
#define _InPlaceBinaryRadixSort4_h
<P>
// Swap that does not check for self-assignment.
template&lt; class _Type &gt;
inline void _swap( _Type& a, _Type& b )
{
	_Type tmp = a;
	a         = b;
	b         = tmp;
}
<P>
template&lt; class _Type &gt;
inline void insertionSortSimilarToSTLnoSelfAssignment( _Type* a, unsigned long a_size )
{
	for ( unsigned long i = 1; i &lt; a_size; i++ )
	{
		if ( a&#91; i &#93; &lt; a&#91; i - 1 &#93; )		// no need to do (j &gt; 0) compare for the first iteration
		{
			_Type currentElement = a&#91; i &#93;;
			a&#91; i &#93; = a&#91; i - 1 &#93;;
			unsigned long j;
			for ( j = i - 1; j &gt; 0 && currentElement &lt; a&#91; j - 1 &#93;; j-- )
			{
				a&#91; j &#93; = a&#91; j - 1 &#93;;
			}
			a&#91; j &#93; = currentElement;	// always necessary work/write
		}
		// Perform no work at all if the first comparison fails - i.e. never assign an element to itself!
	}
}
<P>
template&lt; class _Type &gt;
inline void _binaryRadixSort_wInsertionMinSwapsSymmetric_unsignedOnly( _Type* a, long first, long last, _Type bitMask )
{
	if (( last - first ) &gt; 32 )
	{
		// Split the provided array range into 0's and 1's bins
		long _zerosEndPlusOne = first;						// index is one beyond the last  0's portion
		long _onesEndMinusOne = last;						// index is one before the first 1's portion
		for ( ; _zerosEndPlusOne &lt;= _onesEndMinusOne; )
		{
			if ( 0 == ( bitMask & a&#91; _zerosEndPlusOne &#93; ))	// 0's bin
			{
				_zerosEndPlusOne++;							// grow 0's bin
			}
			else {											// 1's portion
				do	// Locate an element that belongs in 0's portion, to eliminate unnecessary swaps
				{
					if ( 0 != ( bitMask & a&#91; _onesEndMinusOne &#93;))
					{
						_onesEndMinusOne--;					// grow 1's bin of the array
					}
					else
					{
						_swap( a&#91; _zerosEndPlusOne &#93;, a&#91; _onesEndMinusOne &#93; );
						_onesEndMinusOne--;
						_zerosEndPlusOne++;			// grow 0's and 1's - found a perfect swap match
						break;						// switch back to the 0's bin
					}
				} while( _zerosEndPlusOne &lt;= _onesEndMinusOne );
			}
		}
		// Recursively call to sort 0's portion and 1's portion using the next bit lower
		bitMask &gt;&gt;= 1;
		if ( bitMask != 0 )
		{
			if ( first &lt; ( _zerosEndPlusOne - 1 ))
				_binaryRadixSort_wInsertionMinSwapsSymmetric_unsignedOnly( a, first, _zerosEndPlusOne - 1, bitMask );
			if (( _onesEndMinusOne + 1 ) &lt; last )
				_binaryRadixSort_wInsertionMinSwapsSymmetric_unsignedOnly( a, _onesEndMinusOne + 1,  last, bitMask );
		}
	}
	else {
		insertionSortSimilarToSTLnoSelfAssignment( &a&#91; first &#93;, last - first + 1 );
	}
}
inline void binaryRadixSortInPlace( unsigned char* a, unsigned long a_size )
{
	if ( a_size &lt;  2 )	return;
	unsigned char bitMask = 0x80;
<P>
	_binaryRadixSort_wInsertionMinSwapsSymmetric_unsignedOnly( a, 0, a_size - 1, bitMask );
}
inline void binaryRadixSortInPlace( unsigned short* a, unsigned long a_size )
{
	if ( a_size &lt;  2 )	return;
	unsigned short bitMask = 0x8000;
<P>
	_binaryRadixSort_wInsertionMinSwapsSymmetric_unsignedOnly( a, 0, a_size - 1, bitMask );
}
inline void binaryRadixSortInPlace( unsigned long* a, unsigned long a_size )
{
	if ( a_size &lt;  2 )	return;
	unsigned long bitMask = 0x80000000;
<P>
	_binaryRadixSort_wInsertionMinSwapsSymmetric_unsignedOnly( a, 0, a_size - 1, bitMask );
}
inline void binaryRadixSortInPlace( unsigned __int64* a, unsigned long a_size )
{
	if ( a_size &lt;  2 )	return;
	unsigned __int64 bitMask = 0x8000000000000000ui64;
<P>
	_binaryRadixSort_wInsertionMinSwapsSymmetric_unsignedOnly( a, 0, a_size - 1, bitMask );
}
<P>
endif	// _InPlaceBinaryRadixSort_h

</pre>
<div>
<div class="caption">
<b>Listing 4</b>
</div>
</div>
<P>

<P>
When it finds the 0's element, it swaps knowing that both elements involved are going to their final destinations -- into their respective bins.  These two elements will not be swapped again (growing 0's and 1's bin after the swap).  Modified algorithm steps are outlined as follows:
<P>
<div>
<img src="http://i.cmpnet.com/ddj/images/article/2009/0910/091001victor2_e3.gif"> 
</div>
<P>

<P>
This improvement eliminated redundant swaps between elements that both belong to the 1's bin, in the initial implementation.  The number of steps to complete the sort has been reduced dues to the swaps becoming "perfect" (moving both elements of the swap to their respective bins), which allowed for both bins to be grown; see line 5 of example above.  Also, self-assignment has been removed in both cases: when the last element is in the 0's bin or in 1's bin, that bin is grown without self-assignment (which can be seen in the implementation).  
<P>

<P>
This improvement also fixed an asymmetry in the algorithm where in the 0's bin the current pointer was advanced without swapping if the element belonged in the 0's bin, but was not the case for 1's bin.  With the modification, if the element belonged in the 1's bin and was already in the 1's bin location, it was left there and the pointer was advanced to keep searching for an element that did not belong in the 1's bin; for example, looking for a "perfect" swap candidate (where both elements were in the wrong bin before the swap).
<P>

<P>
Another ending condition is possible and is shown below:
<P>
<div>
<img src="http://i.cmpnet.com/ddj/images/article/2009/0910/091001victor2_e4.gif"> 
</div>
<P>

<P>
This ending condition also ends well, with a single perfect swap and both bins being grown.
<P>

<P>
Performance measurements of the final version of Hybrid Binary-Radix Sort along with other algorithms are shown in Tables 5, 6, and 7.  The Intel IPP library does not have an implementation of 32-bit unsigned non-Radix sorting, and for 64-bit unsigned sorting.
<P>
<div>
<img src="http://i.cmpnet.com/ddj/images/article/2009/0910/091001victor2_t5.gif"> 
<div class="caption"> 
<b>Table 5</b>: Random Unsigned Elements 
</div>
</div>
<P>

<P>
Table 5 provides a lot of information, with several notables:
<P>
<ul>
<li>IPP Radix Sort is significantly faster than all other algorithms for 8-, 16-,  and 32-bit unsigned -- 20X faster, 8X and about 3X faster respectively than the closest competitor.
<li>IPP sort performance for 8-bit seems to be the same as IPP Radix Sort, but with the benefit of being in-place.
<li>IPP sort for 16-bit unsigned is significantly worse in performance than the 8-bit version -- 65X.
<li>Hybrid Binary-Radix Sort outperforms STL sort for all data sizes, and IPP sort for 16-bit by at least 15%.
<li>Tables 6 and 7 show that Hybrid Binary-Radix outperforms STL sort and IPP Radix Sort by at least 30% for increasing and decreasing input data sets.
<li>Hybrid Binary-Radix Sort increased in performance over 40% from the initial implementation.
</ul>
<P>
<div>
<img src="http://i.cmpnet.com/ddj/images/article/2009/0910/091001victor2_t6.gif"> 
<div class="caption"> 
<b>Table 6</b>: Increasing 32-bit Unsigned Elements 
</div>
</div>
<P>

<P>

<P>
<div>
<img src="http://i.cmpnet.com/ddj/images/article/2009/0910/091001victor2_t7.gif"> 
<div class="caption"> 
<b>Table 7</b>: Decreasing 32-bit Unsigned Elements 
</div>
</div>
<P>

<P>
Since the generic implementation, through overloaded functions, is data-type-aware it is possible to provide a type-dependent threshold value that controls the switch point for using Insertion Sort.  Brief experiments did not indicate this to be promising, but more detailed investigation may be fruitful.
<P>
<h3>Signed</h3>
<P>

<P>
Signed integers use 2's complement format shown below, with the binary representation on the left and its decimal value on the right:
<P>
<pre  class="code">
<P>
01111111b	127
01111110b	126
01111101b	125
  .
00000001b	1
00000000b	0
11111111b	-1
11111110b	-2
11111101b	-3
  
10000011b	-125
10000010b	-126
10000001b	-127
10000000b	-128

</pre>
<P>

<P>
Note that the most-significant-bit (MSB) serves as the sign bit.  However, its meaning is opposite of what is needed for sorting. If unsigned Binary-Radix Sort algorithm is used, then negative numbers would be interpreted as larger than positive numbers, since negatives have the MSB set to a 1.  However, the rest of the bits have the same meaning as unsigned numbers -- a 1 is bigger than a 0.  Thus, for signed numbers only the MSB must be treaded specially, with the opposite meaning -- a 0 is larger than a 1.  Listing 5 shows an implementation, which treats the sign bit (the MSB) of signed numbers in the opposite manner, followed by recursive calls to the unsigned core routine for the rest of the bits.
<P>
<pre  class="code">
<P>
// Copyright(c), Victor J. Duvanenko, 2009
// In-place Binary Radix Sort implementations.
<P>
#ifndef _InPlaceBinaryRadixSort5_h
#define _InPlaceBinaryRadixSort5_h
<P>
// Swap that does not check for self-assignment.
template&lt; class _Type &gt;
inline void _swap( _Type& a, _Type& b )
{
	_Type tmp = a;
	a         = b;
	b         = tmp;
}
// A set of logical right shift functions to work-around the C++ issue of performing an arithmetic right shift
// for &gt;&gt;= operation on signed types.
inline char logicalRightShift( char a, unsigned long shiftAmount )
{
	return (char)(((unsigned char)a ) &gt;&gt; shiftAmount );
}
inline short logicalRightShift( short a, unsigned long shiftAmount )
{
	return (short)(((unsigned short)a ) &gt;&gt; shiftAmount );
}
inline long logicalRightShift( long a, unsigned long shiftAmount )
{
	return (long)(((unsigned long)a ) &gt;&gt; shiftAmount );
}
inline __int64 logicalRightShift( __int64 a, unsigned long shiftAmount )
{
	return (__int64)(((unsigned __int64)a ) &gt;&gt; shiftAmount );
}
<P>
template&lt; class _Type &gt;
inline void insertionSortSimilarToSTLnoSelfAssignment( _Type* a, unsigned long a_size )
{
	for ( unsigned long i = 1; i &lt; a_size; i++ )
	{
		if ( a&#91; i &#93; &lt; a&#91; i - 1 &#93; )		// no need to do (j &gt; 0) compare for the first iteration
		{
			_Type currentElement = a&#91; i &#93;;
			a&#91; i &#93; = a&#91; i - 1 &#93;;
			unsigned long j;
			for ( j = i - 1; j &gt; 0 && currentElement &lt; a&#91; j - 1 &#93;; j-- )
			{
				a&#91; j &#93; = a&#91; j - 1 &#93;;
			}
			a&#91; j &#93; = currentElement;	// always necessary work/write
		}
		// Perform no work at all if the first comparison fails - i.e. never assign an element to itself!
	}
}
<P>
template&lt; class _Type &gt;
inline void _binaryRadixSort_wInsertionMinSwapsSymmetric_signedOnly( _Type* a, long first, long last, _Type bitMask )
{
	if (( last - first ) &gt; 32 )
	{
		// Split the provided array range into 0's and 1's bins
		long _zerosEndPlusOne = first;						// index is one beyond the last  0's portion
		long _onesEndMinusOne = last;						// index is one before the first 1's portion
		for ( ; _zerosEndPlusOne &lt;= _onesEndMinusOne; )
		{
			if ( 0 != ( bitMask & a&#91; _zerosEndPlusOne &#93; ))	// 0's bin
			{
				_zerosEndPlusOne++;							// grow 0's bin
			}
			else {											// 1's portion
				do	// Locate an element that belongs in 0's portion, to eliminate unnecessary swaps
				{
					if ( 0 == ( bitMask & a&#91; _onesEndMinusOne &#93;))
					{
						_onesEndMinusOne--;					// grow 1's bin of the array
					}
					else
					{
						_swap( a&#91; _zerosEndPlusOne &#93;, a&#91; _onesEndMinusOne &#93; );
						_onesEndMinusOne--;
						_zerosEndPlusOne++;			// grow 0's and 1's - found a perfect swap match
						break;						// switch back to the 0's bin
					}
				} while( _zerosEndPlusOne &lt;= _onesEndMinusOne );
			}
		}
		// Recursively call to sort 0's portion and 1's portion using the next bit lower
		bitMask = logicalRightShift( bitMask, 1 );
		if ( bitMask != 0 )
		{
			if ( first &lt; ( _zerosEndPlusOne - 1 ))
				_binaryRadixSort_wInsertionMinSwapsSymmetric_unsignedOnly( a, first, _zerosEndPlusOne - 1, bitMask );
			if (( _onesEndMinusOne + 1 ) &lt; last )
				_binaryRadixSort_wInsertionMinSwapsSymmetric_unsignedOnly( a, _onesEndMinusOne + 1,  last, bitMask );
		}
	}
	else {
		insertionSortSimilarToSTLnoSelfAssignment( &a&#91; first &#93;, last - first + 1 );
	}
}
inline void binaryRadixSortInPlace( char* a, unsigned long a_size )
{
	if ( a_size &lt;  2 )	return;
	char bitMask = (char)0x80;
<P>
	_binaryRadixSort_wInsertionMinSwapsSymmetric_signedOnly( a, 0, a_size - 1, bitMask );
}
inline void binaryRadixSortInPlace( short* a, unsigned long a_size )
{
	if ( a_size &lt;  2 )	return;
	short bitMask = (short)0x8000;
<P>
	_binaryRadixSort_wInsertionMinSwapsSymmetric_signedOnly( a, 0, a_size - 1, bitMask );
}
inline void binaryRadixSortInPlace( long* a, unsigned long a_size )
{
	if ( a_size &lt;  2 )	return;
	long bitMask = 0x80000000;
<P>
	_binaryRadixSort_wInsertionMinSwapsSymmetric_signedOnly( a, 0, a_size - 1, bitMask );
}
inline void binaryRadixSortInPlace( __int64* a, unsigned long a_size )
{
	if ( a_size &lt;  2 )	return;
	__int64 bitMask = 0x8000000000000000i64;
<P>
	_binaryRadixSort_wInsertionMinSwapsSymmetric_signedOnly( a, 0, a_size - 1, bitMask );
}
<P>
endif	// _InPlaceBinaryRadixSort_h

</pre>
<div>
<div class="caption">
<b>Listing 5</b>
</div>
</div>
<P>

<P>
This implementation uses overloaded functions to handle all signed types from 8-bit to 64-bits.  This fits nicely with the unsigned functions to provide a consistent and fairly generic implementation that handles unsigned and signed types using the same interface, as well as the same function name. Correctness of the signed implementation was tested using the same test procedure as for unsigned versions of the algorithm.
<P>

<P>
Signed implementation has another slight difference -- it uses an overloaded function <b>logicalRightShift()</b>.  This function was necessary because C++ defines right shift operation "&gt;&gt;" for signed number as an arithmetic shift and not a logical shift, which is not the behavior that is needed.  Interestingly, Java defines a "&gt;&gt;&gt;" operator, which implements a logical shift on signed numbers &#91;6&#93; and "&gt;&gt;" performs an arithmetic shift.  It's unfortunate that C++ is stuck with this behavior, most likely for backwards compatibility with C, since it would be clearer to have "&gt;&gt;" mean logical shift and "/2" mean arithmetic shift for both unsigned and signed integers.  Capable compilers already optimize "integer divide by power of 2 constant" as an arithmetic shift.

			
				<h3>Comparing Order</h3>
<P>

<P>
Comparing algorithms of dissimilar performance order, such as <b><i>O</i>(nlogn)</b> for STL sort and  <b><i>O</i>(kn)</b> for Radix-Sort, should provide insight about when one algorithm is expected to be better than another.  The comparison is easier to see if the orders are put in a similar form, such as <b><i>O</i>(log<sub>2</sub>(n)*n)</b> and <b><i>O</i>(k*n)</b>.  Both formulas have an <b>n</b> term in common, and thus the comparison is between <b>log<sub>2</sub>(n)</b> and <b>k</b> &#91;3&#93;.  Another way to see this is to divide the two formulas.  In this case, <b>n</b> cancels out and <b>log<sub>2</sub>(n)/k</b> ratio remains.  If <b>log<sub>2</sub>(n)</b> is bigger than <b>k</b>, the ratio will be bigger than 1.  If <b>k</b> is bigger, the ratio will be less than 1.
<P>

<P>
Table 8 demonstrates this relationship.  It shows that <b>log<sub>2</sub>(n)</b> increases by one when <b>n</b> doubles -- which follows from one of the rules of logarithms, where <b>log( m*n ) = log(m) + log(n)</b>.  In this case, <b>log<sub>2</sub>( 2*n ) = log<sub>2</sub>(2) + log<sub>2</sub>(n) = 1 + log2(n)</b>.  The second portion of the table shows that for <b>log<sub>2</sub>(n)</b>to double, <b>n</b> has to square, which follows from another rule of logarithms, where <b>m*log(n) = log(n<sup>m</sup>)</b>, where <b>m=2</b> in this case.
<P>
<div>
<img src="http://i.cmpnet.com/ddj/images/article/2009/0910/091001victor2_t8.gif"> 
<div class="caption"> 
<b>Table 8</b>
</div>
</div>
<P>

<P>
In Table 8 one of the entries is <b>log<sub>2</sub>(4.3*10<sup>9</sup>)=32</b> -- for example, <b>n = 4.3E+9</b>, or 4.3 billion.  For this case, when the array contains 4.3 billion elements, then <b><i>O</i>(log(n)*n ) = 32*4.3*10<sup>9</sup></b>, which is the estimate of the number of comparisons for the STL sort algorithm.
<P>

<P>
For Binary-Radix Sort, the order is <b><i>O</i>(k*n)</b>, where <b>k</b> is the number of bits in each element.  If the elements are 32-bits each, then <b><i>O</i>(k*n) = 32*4.3*10<sup>9</sup></b>  operations for an array with 4.3 billion elements.  In this case, the estimates for STL sort and Binary-Radix Sort are equal.  For the case of 8-bit elements, Binary-Radix Sort estimate is <b>8*4.3*10<sup>9</sup></b>, whereas STL estimate stays at <b>32*4.3*10<sup>9</sup></b>, predicting Binary-Radix Sort to be faster.  For the case of 64-bit elements, the Binary-Radix-Sort estimate is <b>64*4.3*10<sup>9</sup></b>, whereas STL estimate stays at <b>32*4.3*10<sup>9</sup></b>, predicting STL sort to be faster.
<P>

<P>
These examples demonstrate that STL sort performance is estimated only from the number of elements in the array and not their size, whereas Binary-Radix Sort is estimated from the number of bits of each element and the number of elements.  The order formulas predict that Binary-Radix Sort should be faster than STL sort (actually any optimal comparison sort) when the elements are made of a few bits, but that STL sort should be faster when the element size is large.
<P>
Tables 9 show measured performance comparisons.  Intel IPP does not implement 8-bit and 64-bit signed integer sorting in non-Radix and Radix sorting.
<P>
<div>
<img src="http://i.cmpnet.com/ddj/images/article/2009/0910/091001victor2_t9.gif"> 
<div class="caption"> 
<b>Table 9</b>: Random Signed Elements
</div>
</div>
<P>

<P>
Table 9 provides a lot of information, with several notables:
<P>
<ul>
<li>All algorithms performed consistently with their unsigned counterparts (when existed), where signed and unsigned performance was nearly equal.
<li>IPP Radix Sort is significantly faster than all other algorithms for 16 and 32-bit signed -- 8X and about 3X faster respectively than the closest competitor.
<li>Order predictions hold accurately for Hybrid Binary-Radix Sort for 8, 16 and 32-bit cases, where the performance decreases by 2X as the number of bits (k) increases by 2X.  However, for 64-bit case the performance does not decrease by 2X as predicted, but increases by about 16%.
<li>Order prediction is not accurate for STL sort, expecting the performance not to depend on the size of array elements, but only on the number of elements.  However, STL sort performance decreases by 2X as the number of bits increases by 2X, for 8, 16 and 32-bit cases, but not for 64-bit.
<li>Order prediction for STL sort to beat Binary-Radix Sort did not hold for up to 64-bits.
</ul>
<P>

<P>
At first it may seem that Binary-Radix sort is a good candidate for multicore and multithreading.  It splits the data set into two portions and then splits those further recursively.  However, the split of the array is data dependent.  In other words, the split will not always be even, which leads to uneven load balancing.  This may be one of the reasons that Intel did not multithread its Radix-Sort implementation.
<P>
<h3>Conclusions</h3>
<P>

<P>
In-place Hybrid Binary-Radix Sort (MSD-style) algorithm was developed and improved through several performance optimizations.  Insertion Sort was used at the bottom of the recursion tree.  Over 40% performance improvement was achieved from the initial implementation, by removing redundant operations.  The implementation was extended to handle unsigned and signed integers from 8-bits to 64-bits.  A data-type-aware generic interface, overloaded functions, was used to encapsulate unique unsigned and signed implementations under a common interface.  The resulting algorithm compared favorably with STL sort implementation, outperforming it by at least 15% for random input data and 32 & 64-bit increasing and decreasing data sets.
<P>

<P>
Comparison to Intel's IPP sort (in-place) and Radix sort (not in-place) was also performed, where IPP's Radix Sort was found to perform 20X, 8X and about 3X faster for 8-bit, 16-bit and 32-bit unsigned respectively.  Hybrid Binary-Radix Sort outperformed IPP's sort for 16 and 32-bit data types, but lagged by 20X for 8-bit unsigned data type.
<P>

<P>
Inconsistencies in using algorithm order for performance prediction were found for STL sort for most data sizes, whereas Hybrid Binary-Radix Sort was predicted consistently except for 64-bit data size.
<P>

<P>
A further hybrid in-place algorithm can be evolved by combining the best attributes of Intel's IPP algorithms with in-place Hybrid Binary-Radix Sort.  For instance, the high-performance IPP 8-bit in-place sort can be integrated under the generic interface developed.  For the 8-bit unsigned overloaded function implementation, Intel's IPP sort function would be called.  The combined algorithm would retain its generic interface, but yet would have data type specific optimized implementations.  This leads to "generic data type adaptive" algorithms, which would retain a generic interface and adapt to perform optimally for each data type.  Purely generic algorithms miss this opportunity, as well as the 20X performance improvement shown for 8-bit data types.
<P>

<P>
Floating-point support would be a nice extension.  Intel IPP sorting routines support floating-point: single and double-precision.  Creating a more sophisticated generic implementation, such as STL's, would allow custom classes to be sorted.  The use of iterators would reduce the number of items passed to each level of recursion from currently 4 down to 3 (first and last iterator, and bitMask), possibly improving performance.
<P>
<h3>References</h3>
<P>

<P>
&#91;1&#93; Intel Integrated Performance Primitives for Intel Architecture, Reference Manual, Volume 1: Signal Processing, August 2008, pp. 5-57 - 5-61.
<P>

&#91;2&#93; http://en.wikipedia.org/wiki/Radix_sort
<P>

&#91;3&#93;Jim Vaught of Arxan Defense Systems -- personal discussion.
<P>

&#91;4&#93; V. J. Duvanenko, <a href="http://www.ddj.com/cpp/220000504">Algorithm Improvement through Performance Measurement: Part 1</a>, Dr. Dobb's 
<P>

&#91;5&#93; Scott Miller of Arxan Defense Systems -- personal discussion.
<P>

&#91;6&#93; http://en.wikipedia.org/wiki/Bitwise_operation
<P>

<P>

<P>

<P>

			
		<!-- /ARTICLE BODY -->

		 
		<P><!--this page will come at integration-->
		



		<!-- http://as.cmpnet.com/html.ng/pagepos=bottom&affiliate=ddj&site=sdmg&country=russian_federation&server=atg&target=/article/printableArticle.jhtml -->
<META HTTP-EQUIV="Content-type" CONTENT="text/html;charset=ISO-8859-1">
<script src="http://as.cmpnet.com/DartRichMedia_1_03.js"></script>
<!-- Sniffer Code for Flash version=80 -->
<SCRIPT LANGUAGE=JavaScript>
<!--
var swf_click = "http://as.cmpnet.com/event.ng/Type=click&FlightID=148171&AdID=232926&TargetID=1251&Segments=1551,3108,3448,4875,5470,11862,14770&Targets=1251,2625,2878,4879&Values=34,46,51,63,77,87,90,102,140,204,442,774,944,945,975,1766,1785,1925,1970,2151,2299,2329,2352,2678,3351,3363,4079,6293,6393,6489,6541,6567,6967,7062&RawValues=&Redirect=http://www.ddj.com/go-parallel/?cid=DDJ_LB";
var dcswf_click = escape(swf_click);
var ShockMode = 0;
var plugin = (navigator.mimeTypes && navigator.mimeTypes["application/x-shockwave-flash"]) ? navigator.mimeTypes["application/x-shockwave-flash"].enabledPlugin : 0;

if (plugin && parseInt(plugin.description.substring(plugin.description.indexOf(".")-2)) >= 8) 
{
ShockMode = 1;
}
else if (navigator.userAgent && navigator.userAgent.indexOf("MSIE")>=0 
&& (navigator.userAgent.indexOf("Windows 95")>=0 || navigator.userAgent.indexOf("Windows 98")>=0 || navigator.userAgent.indexOf("Windows NT")>=0)) {
document.write('<SCRIPT LANGUAGE=VBScript\> \n');
document.write('on error resume next \n');
document.write('ShockMode = (IsObject(CreateObject("ShockwaveFlash.ShockwaveFlash.8")))\n');
document.write('<\/SCRIPT\> \n');
}
if ( ShockMode ) {
document.write('<OBJECT classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"');
document.write(' codebase="http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=8,0,0,0"');
document.write(' ID=flashad WIDTH=728 HEIGHT=90>');
document.write(' <PARAM NAME=movie VALUE="http://i.cmpnet.com/ads/graphics/as5/kh/int/728x90_Intel_Go_Parallel.swf?clickTag='+dcswf_click+'"> '); 
document.write(' <PARAM NAME=quality VALUE=autohigh> ');
document.write(' <PARAM NAME=wmode VALUE=opaque> ');
document.write(' <EMBED SRC="http://i.cmpnet.com/ads/graphics/as5/kh/int/728x90_Intel_Go_Parallel.swf?clickTag='+dcswf_click+'" QUALITY=autohigh WMODE=opaque '); 
document.write(' NAME=flashad swLiveConnect=TRUE WIDTH=728 HEIGHT=90');
document.write(' TYPE="application/x-shockwave-flash" PLUGINSPAGE="http://www.macromedia.com/shockwave/download/index.cgi?P1_Prod_Version=ShockwaveFlash">');
document.write('</EMBED>');
document.write('</OBJECT>');
} else if (!(navigator.appName && navigator.appName.indexOf("Netscape")>=0 && navigator.appVersion.indexOf("2.")>=0)){
document.write('<A HREF="http://as.cmpnet.com/event.ng/Type=click&FlightID=148171&AdID=232926&TargetID=1251&Segments=1551,3108,3448,4875,5470,11862,14770&Targets=1251,2625,2878,4879&Values=34,46,51,63,77,87,90,102,140,204,442,774,944,945,975,1766,1785,1925,1970,2151,2299,2329,2352,2678,3351,3363,4079,6293,6393,6489,6541,6567,6967,7062&RawValues=&Redirect=http://www.ddj.com/go-parallel/?cid=DDJ_LB" target="_top"><IMG SRC="http://i.cmpnet.com/ads/graphics/as5/kh/blank.gif" WIDTH=728 HEIGHT=90 BORDER=0></A>');
}
//-->
</SCRIPT>
<NOEMBED>
<A HREF="http://as.cmpnet.com/event.ng/Type=click&FlightID=148171&AdID=232926&TargetID=1251&Segments=1551,3108,3448,4875,5470,11862,14770&Targets=1251,2625,2878,4879&Values=34,46,51,63,77,87,90,102,140,204,442,774,944,945,975,1766,1785,1925,1970,2151,2299,2329,2352,2678,3351,3363,4079,6293,6393,6489,6541,6567,6967,7062&RawValues=&Redirect=http://www.ddj.com/go-parallel/?cid=DDJ_LB" target="_top"><IMG SRC="http://i.cmpnet.com/ads/graphics/as5/kh/blank.gif" WIDTH=728 HEIGHT=90 BORDER=0></A>
</NOEMBED>
<NOSCRIPT>
<A HREF="http://as.cmpnet.com/event.ng/Type=click&FlightID=148171&AdID=232926&TargetID=1251&Segments=1551,3108,3448,4875,5470,11862,14770&Targets=1251,2625,2878,4879&Values=34,46,51,63,77,87,90,102,140,204,442,774,944,945,975,1766,1785,1925,1970,2151,2299,2329,2352,2678,3351,3363,4079,6293,6393,6489,6541,6567,6967,7062&RawValues=&Redirect=http://www.ddj.com/go-parallel/?cid=DDJ_LB" target="_top"><IMG SRC="http://i.cmpnet.com/ads/graphics/as5/kh/blank.gif" WIDTH=728 HEIGHT=90 BORDER=0></A>
</NOSCRIPT>

<img src="http://as.cmpnet.com/event.ng/Type=count&ClientType=2&AdID=232926&FlightID=148171&TargetID=1251&SiteID=944&AffiliateID=975&EntityDefResetFlag=0&Segments=1551,3108,3448,4875,5470,11862,14770&Targets=1251,2625,2878,4879&Values=34,46,51,63,77,87,90,102,140,204,442,774,944,945,975,1766,1785,1925,1970,2151,2299,2329,2352,2678,3351,3363,4079,6293,6393,6489,6541,6567,6967,7062&RawValues=&random=xbpoAr,bfmRcrxfcghN" width=1 height=1 border=0>

	
		<P>
		<FONT SIZE="1" face="geneva,ms sans serif,helvetica">Copyright &#169; 2009 <A HREF="http://www.unitedbusinessmedia.com/">United Business Media LLC</A></FONT>
		</BODY>
		</HTML>
	